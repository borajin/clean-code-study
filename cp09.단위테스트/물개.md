## TDD 법칙 세 가지
아래 세 가지 법칙은 실제 코드를 사실상 전부 테스트하는 테스트 케이스가 나오도록 한다.

1. 실제 코드는 **실패하는 단위 테스트**를 작성한 뒤에야 한다
2. 실제 코드는 **현재 실패하는 테스트 코드를 통과**하는 정도로만
3. **실패하지 않는 컴파일, 실패하는 실행** 원칙

하지만 많은 테스트 케이스는 심각한 관리 문제를 유발하므로 아래 원칙을 준수해야한다.

#### 깨끗한 테스트 코드
테스트 코드는 실제 코드와 같이 중요하다
##### 테스트 케이스가 없는 것보다 낫다? 
없는 것보다 낫다는 생각으로 테스트 코드를 깨끗하게 만드는 것은 틀린 생각이다

1. 실제 코드가 변하면 테스트 코드가 변하게 되고, 지저분한 테스트 코드를 이해하고 변경하는데 많은 시간이 소요된다
2. 새 버전을 출시할 때 마다 테스트 케이스를 유지보수하는데 들어가는 비용이 늘어난다
3. 점차 개발자 사이에서 테스트 코드는 불만으로 전락한다
4. 결국 테스트 슈트를 폐기하는 상황이 된다  
5. 하지만 테스트 슈트가 없으면 부작용이 발생하기 시작한다. **자신이 수정한 코드가 제대로 작동하는지 확인할 방법이 없으며, 수정한 코드로 인해 발생하는 다른 코드에서의 사이드 이펙트를 검증하지 못한다**
6. 부작용이 늘어남에 따라 시스템의 결함율이 높아진다. 의도하지 않은 결함이 늘어나면 개발자는 변경을 주저하며 더 이상 코드를 정리하지 않는다
7. 그렇게 코드가 망가지게 된다

#### 유연성, 유지보수성, 재사용성을 제공
* 테스트 케이스는 코드에 유연성, 유지보수성, 재사용성을 제공하는 버팀목이다
* 테스트 케이스가 없다면 모든 변경은 잠정적 버그다, 테스트 케이스가 있어야 변경이 쉬워진다
* 자동화된 단위 테스트 슈트는 설계와 아키텍처를 최대한 깨끗히 보존하는 열쇠다
* 지저분한 테스트 케이스는 지저분한 실제 코드를 야기한다
 
#### 깨끗한 테스트 코드 만들기
* 첫째도 가독성 둘째도 가독성 셋째도 가독성
* 명료성, 단순성, 풍부한 표현력으로 가독성을 높일 수 있다
* 최소의 표현으로 많은 것을 나타내야 한다
* **build-operate-check 패턴**
	*  테스트 시나리오를 만들기 -> 메서드를 실행하기 -> 실행 결과가 올바른지 확인
* 도메인 특화 테스트 언어 DSL
	* 테스트를 구현하는 당사자와 나중에 테스트를 읽어볼 독자를 도와주는 테스트 언어로 작성되어야 한다
* 이중 표준
	- 단순하고, 간결하고, 표현력이 풍부해야 하지만, 실제 코드만큼 효율적일 필요는 없다
* 테스트 당 개념 하나
* F.I.R.S.T
	* Fast 빠르게
		테스트는 빠른 주기로 돌려야 한다, 자주 돌리지 않으면 문제를 일찍 찾지 못한다
	* Independent 독립적
		각 테스트는 서로 의존하면 안 된다, 어떤 순서로 실행해도 괜찮아야 한다. 하나가 실패할 때 나머지도 잇달아 실패하므로 원인 진단이 어려워지며, 후반 테스트가 찾아내야할 결함이 숨겨진다
	* Repeatable 반복 가능
		어떤 환경에서도 반복 가능해야 한다, 네트워크 등 어떠한 환경에도 테스트를 수행하지 못하는 배경은 없어야한다
	* Self-Validating 자가 검증
		테스트는 불린 값으로 결과를 내야 한다
	* Timely 적시에
		단위 테스트는 테스트하려는 실제 코드 구현 직전에 구현한다

