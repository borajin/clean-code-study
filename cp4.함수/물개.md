
##### 작게 더 작게
함수는 작고 간결하게. 
작은 함수는 코드의 가독성을 높인다.
##### 블록과 들여쓰기
If-esle문 혹은 while문 등에 들어가는 블록에서 함수를 호출해야하며 함수에서 들여쓰기 수준은 2단을 넘어서면 안된다.

## 한 가지 역할

> 함수는 한 가지를 해야 한다. 그 한 가지를 잘 해야 한다. 그 한 가지만을 해야 한다.

함수는 한 의미를 가져야하며, 또 다른 의미 있는 이름으로 추출할 수 없어야 한다.

##### 동일한 추상화 수준
추상화를 사용하여 설계 패턴을 사용하여 코드의 가독성과 재사용성을 높인다.
함수 내 모든 문장의 추상화 수준은 동일해야한다
고수준의 추상화는 함수의 이름에 비즈니스 논리나 개념을 명확히 드러내 보여야한다
###### 내려가기 규칙
함수는 한가지 역할만 하며 동일한 추상화 수준을 갖는다, 그러므로 고수준 추상화 단계를 가진 함수는 세부 구현을 숨겨야 한다 세부 단계를 구현하는 함수는 저수준 추상화 함수다.

**추상화 분류** 
1. **작업 수준:
   - **고수준 추상화**: 높은 수준의 작업 또는 개념을 다룬다. 비즈니스적인 작업을 다룸
   - **저수준 추상화**: 더 구체적인 작업 또는 세부사항을 다룸. 알고리즘 또는 구현 세부사항을 포함함

2. **세부사항 숨김**:
   - **고수준 추상화**: 구체적인 구현 세부사항을 숨김 
   - **저수준 추상화**: 내부 로직 등 구체적인 구현을 다룸

3. **재사용성**:
   - **고수준 추상화**: 일반적인 작업을 추상화하기 때문에 여러 상황에서 재사용 가능
   - **저수준 추상화**: 주로 특정 작업 또는 알고리즘을 다루므로 재사용성이 상대적으로 낮을 수 있음

4. **가독성 :
   - **고수준 추상화**: 코드를 더 이해하기 쉽게 만들어주고, 코드의 의도를 명확하게 전달.
   - **저수준 추상화**: 구체적인 구현 세부사항을 다루므로 코드의 복잡성 증가

5. **유지 보수**:
   - **고수준 추상화**: 코드를 간단하게 유지하고, 변경이 필요할 때 비교적 쉽게 수정 가능
   - **저수준 추상화**: 내부 구현에 대한 변경이 필요할 때 관련된 코드를 수정해야 함

#### switch 문
본질적으로 스위치 문은 여러개를 처리하고 코드가 변경될 여지가 크므로, 저차원 클래스에 숨기고 다형성을 이용한다. 
// Payroll.java

// Employee and Factory.java

### 의미있는, 일관성 있는, 역할이 드러나는 이름
##### 가독성
이름은 쉽게 읽혀야하며, 기능과 의도를 파악할 수 있어야한다. (ex. 이벤트는 이벤트라는 사실이 드러나게 할 것) 
##### 부수 효과 최소화
함수 역할과 이름은 같아야한다. 함수 이름보다 더 많은 역할을 하여 의도치 않은 상태가 변경되서는 안된다. 코드의 예측 가능성을 높여야 한다.

##### 명령과 조회 분리
명령 함수는 어떤 동작을 수행하고 결과를 반환하지 않아야 하며, 조회 함수는 결과를 반환하거나 변경을 일으키지 않아야 한다.

#### 오류 코드보다 예외 처리
오류 코드 클래스는 의존성 자석으로, 코드의 유지보수성을 하락시킨다.  예외는 Exception 클래스에서 파생되므로 재컴파일, 재배치 없이 새 예외 클래스를 추가할 수 있다. 

#### 중복 제어



### 함수 인수 관리
함수에 전달되는 인수의 수를 최소화해야 한다. 많은 인수는 함수의 이해와 사용이 어려워진다. 많은 인수는 객체로 묶어 전달한다.(인수의 개념을 더 명확히 할 수 있다.)

* 잘 못 된 예시
1. 단항 함수
	변환 함수에서 출력 인수를 사용하는 경우
2. 단항 함수
	입력 인수를 변환하고 출력 인수를 사용하지 않는 경우 (입력 인수를 그대로 반환하더라도 형식을 따를 것)
3. 플래그 인수 
	플래그 인수를 넘기지 않도록 한다. 함수 내에서 여러가지를 처리하지 않아야 한다.
4. 이항 함수
	
	



--- 
SRP :  단일 책임 원칙
하나의 모듈은 하나의, 오직 하나의 액터에 대해서만 책임을 져야 한다
